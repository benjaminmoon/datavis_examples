---
title: UK cases of COVID-19
author: Ben Moon
email: ben@bcmoon.uk
---

We use [*renv*](https://rstudio.github.io/renv/ "renv reproducible environments") to maintain environments and package versions.

```{r setup}
renv::restore()

library(cowplot)
library(geojsonio)
library(gganimate)
library(ggthemes)
library(sf)
library(sugarbag)
library(tidyverse)
library(viridis)

theme_set(theme_clean())
```

The U.K. government makes daily coronavirus updates available at <https://coronavirus.data.gov.uk>. Their API (v2) allows these data to be downloaded, including only specified data. In this case we get the number of new cases and new admissions in CSV format. We use *newCasesBySpecimenDate* to show the number for each day, although this is liable to change later as new cases are reported.

```{r covid_data}
covid_data_url <-
  paste0(
    "https://api.coronavirus.data.gov.uk/v2/data?",
    "areaType=utla&",
    "metric=newCasesBySpecimenDate&",
    "metric=newAdmissions&",
    "format=csv"
  )
covid_data <-
  read_csv(covid_data_url)
covid_data
```

Area Codes have prefix E, N, S or W to indicate the country it's in, and the initial number (10 or 06) I think shows whether it's a county or UTLA. There doesn't seem to be any data recorded in *newAdmissions*.

These data are grouped by *Upper Tier Local Authority* (UTLA), which equates to county level in the U.K. Geographical data for UTLAs are available the [U.K. government geoportal](https://geoportal.statistics.gov.uk "UK Office for National Statistics Geoportal.") and the Office for National Statistics. In particular, [this link](https://geoportal.statistics.gov.uk/datasets/counties-and-unitary-authorities-december-2017-ultra-generalised-clipped-boundaries-in-uk-wgs84?geometry=-59.691%2C51.183%2C52.809%2C59.848 "UK Counties and Unitary Authorities (December 2017) Ultra Generalised Clipped Boundaries in UK (WGS84)") will take you to the data used, although the GeoJSON files are hosted at <opendata.arcgis.com>.

```{r utla_areas}
utla_geojson_url <-
  paste0(
    "https://opendata.arcgis.com/datasets/",
    "658297aefddf49e49dcd5fbfc647769e_4.geojson"
  )
utla_sf <-
  geojson_sf(utla_geojson_url)
utla_sf
```

Our first step should be to plot the data we've downloaded, both of which are easy enough.

```{r check_covid_data, fig.cap = "UK COVID-19 new cases by specimen date"}
covid_data %>%
  ggplot(aes(x = date, y = newCasesBySpecimenDate, colour = areaCode)) +
  geom_line(show.legend = FALSE) +
  scale_colour_viridis(discrete = TRUE)
```

```{r check_utla_data, fig.cap = "UK upper tier local authority boundaries"}
utla_sf %>%
  ggplot() +
  geom_sf() +
  theme_map()
```

While the time series data is fine, it's difficult to see all of the different regions, although there are many. 

```{r covid_regions, fig.cap = "**New UK COVID-19 cases per region.** The highest peaks later in the series occur in London and the South east in January 2021."}
covid_data %>%
  ggplot(
    aes(
      x = date,
      y = newCasesBySpecimenDate
    )
  ) +
    geom_line() +
    facet_wrap(vars(areaCode)) +
    theme_void() +
    theme(strip.text = element_text(size = 4))
```

It'll take a little more looking to sort out the order of the plots: does the areaCode have an order associated with it?

We can, however, join these data to the map to see the occurrences of cases on a particular day.

```{r feb_cases_join}
covid_feb_joined <-
  covid_data %>%
    filter(date == "2021-02-01") %>%
    left_join(utla_sf, ., by = c("ctyua17cd" = "areaCode"))
```

The are code is matched between the two data sets as they're joined. Here we plot a map, but also a tesselogram or hexagram that shows each region at equal size but still in approximate location. Doing this uses the *sugarbag* package, which includes a lot of functions to make this easy, but doesn't produce the most meaning full hexagram at the end. I'm not sure whether this is my settings, the package, or the area outlines that is the root cause of this. 

```{r arrange_hexagram, message = FALSE}
hex_size <- 0.6

utla_centroids <-
  utla_sf %>%
  create_centroids(sf_id = "ctyua17cd")
utla_grid <-
  utla_centroids %>%
  create_grid(
    hex_size = hex_size,
    buffer_dist = 12
  )
utla_hex_allo <-
  allocate(
    utla_centroids,
    hex_grid = utla_grid,
    sf_id = "ctyua17cd",
    hex_size = hex_size,
    hex_filter = 20,
    width = 30,
    verbose = TRUE
  )
utla_hexes <-
  utla_hex_allo %>%
    fortify_hexagon(
      hex_size = hex_size,
      sf_id = "ctyua17cd"
    ) %>%
    left_join(
      covid_data %>%
        filter(date == "2021-04-01"),
      by = c("ctyua17cd" = "areaCode")
    ) %>%
    mutate(
      poly_type = "hex",
      group = ctyua17cd
    )
```

I've stuck a lot of the workings into this following function.

```{r map_plotting_funcs}
plot_map_figure <-
  function(
    shape_data,
    hexagon_data,
    fill_variable = "newCasesBySpecimenDate"
  ) {
  # Plot a figure of Local Authority data with both a choropleth map and tesselated hexagram.
  choropleth_map <-
    shape_data %>%
      ggplot() +
        geom_sf(
          aes_(fill = as.name(fill_variable)),
          lwd = 0.2
        ) +
        theme_map() +
        scale_fill_viridis(discrete = FALSE)
  choropleth_hexagram <-
    hexagon_data %>%
    ggplot(aes_(fill = as.name(fill_variable))) +
      geom_polygon(
        aes(x = long, y = lat, group = group)
      ) +
      theme_map() +
      scale_fill_viridis(discrete = FALSE)
  legend <-
    get_legend(
      choropleth_map +
        theme(legend.box.margin = margin(0, 0, 0, 15)) +
        labs(fill = "")
    )
  maps <-
    plot_grid(
      choropleth_map +
        theme(legend.position = "none"),
      choropleth_hexagram +
        theme(legend.position = "none"),
      labels = "AUTO",
      rel_widths = c(1.5, 2)
    )
  plot_grid(maps, legend, rel_widths = c(3, 0.6))
}

cp_title <-
  function(title) {
  ggdraw() +
    draw_label(
      title,
      fontface = "bold",
      x = 0,
      hjust = 0
    ) +
    theme(
      # add margin on the left of the drawing canvas,
      # so title is aligned with left edge of first plot
      plot.margin = margin(0, 0, 0, 7)
    )
  }
```

So that all the tricky plotting can be hidden away in this function.

```{r plot_map, fig.cap = "**New UK COVID-19 cases on the 1 February 2021.** Geographical map (A) and hexagram (B) of the raw number of new cases in each Upper Tier Local Authority.", fig.width = 7.6, fig.height = 4.7}
map_w_legend <-
  plot_map_figure(
    shape_data = covid_feb_joined,
    hexagon_data = utla_hexes,
    fill_variable = "newCasesBySpecimenDate"
  )

title <-
  cp_title(
    "New cases of COVID-19 in UK Local Authorities on 1 February 2021."
  )

plot_grid(
  title,
  map_w_legend,
  ncol = 1,
  rel_heights = c(0.1, 1)
)
# save_plot(
#   "map_figure.pdf",
#   figure,
#   base_height = 120,
#   base_asp = 1.618,
#   units = "mm"
# )
```

It's also useful to plot the changes over time, here compared to the week before. We'll use this as it will show longer term trends, but also because that will help account for differences in reported due to, e.g., weekends. Above zero is an increasing number of cases, below zero is a decreasing number of cases.

```{r weekly_changes_time_series, fig.cap = "**Weekly change in new UK cases of COVID-19 by Upper tier Local Authority**"}
weekly_changes <-
  covid_data %>%
    arrange(date) %>%
    group_by(areaCode) %>%
    mutate(
      weekly_case_change =
        newCasesBySpecimenDate - lag(newCasesBySpecimenDate, n = 7L)
    )

weekly_changes %>%
  ggplot(
    aes(
      x = date,
      y = weekly_case_change
    )
  ) +
    geom_line() +
    theme_void() +
    theme(strip.text = element_text(size = 4)) +
    facet_wrap(vars(areaCode))
```

Finally, this video shows the daily new cases for each UTLA through the whole pandemic.

```{r animate_map, message = FALSE}
n_days <-
  covid_data %>%
  summarise(unique(date)) %>%
  nrow()
animated <-
  weekly_changes %>%
  left_join(utla_sf, ., by = c("ctyua17cd" = "areaCode")) %>%
  mutate(log_newCases = log(newCasesBySpecimenDate)) %>%
  ggplot() +
    geom_sf(
      aes(fill = log_newCases),
      lwd = 0.2
    ) +
    geom_text(x = 0, y = 56, aes(label = date)) +
    theme_map() +
    scale_fill_viridis(discrete = FALSE) +
    transition_manual(date, cumulative = FALSE)
animate(animated, nframes = n_days, renderer = ffmpeg_renderer())
# anim_save("map_animation.mp4", animated, nframes = n_days, renderer = ffmpeg_renderer())
```

